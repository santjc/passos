// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package repository

import (
	"database/sql/driver"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AvailabilityStatus string

const (
	AvailabilityStatusAVAILABLE AvailabilityStatus = "AVAILABLE"
	AvailabilityStatusFREESALE  AvailabilityStatus = "FREESALE"
	AvailabilityStatusSOLDOUT   AvailabilityStatus = "SOLD_OUT"
	AvailabilityStatusLIMITED   AvailabilityStatus = "LIMITED"
	AvailabilityStatusCLOSED    AvailabilityStatus = "CLOSED"
)

func (e *AvailabilityStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AvailabilityStatus(s)
	case string:
		*e = AvailabilityStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for AvailabilityStatus: %T", src)
	}
	return nil
}

type NullAvailabilityStatus struct {
	AvailabilityStatus AvailabilityStatus `json:"availability_status"`
	Valid              bool               `json:"valid"` // Valid is true if AvailabilityStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAvailabilityStatus) Scan(value interface{}) error {
	if value == nil {
		ns.AvailabilityStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AvailabilityStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAvailabilityStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AvailabilityStatus), nil
}

type AvailabilityType string

const (
	AvailabilityTypeSTARTTIME    AvailabilityType = "START_TIME"
	AvailabilityTypeOPENINGHOURS AvailabilityType = "OPENING_HOURS"
)

func (e *AvailabilityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AvailabilityType(s)
	case string:
		*e = AvailabilityType(s)
	default:
		return fmt.Errorf("unsupported scan type for AvailabilityType: %T", src)
	}
	return nil
}

type NullAvailabilityType struct {
	AvailabilityType AvailabilityType `json:"availability_type"`
	Valid            bool             `json:"valid"` // Valid is true if AvailabilityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAvailabilityType) Scan(value interface{}) error {
	if value == nil {
		ns.AvailabilityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AvailabilityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAvailabilityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AvailabilityType), nil
}

type BookingStatus string

const (
	BookingStatusONHOLD    BookingStatus = "ON_HOLD"
	BookingStatusCONFIRMED BookingStatus = "CONFIRMED"
	BookingStatusEXPIRED   BookingStatus = "EXPIRED"
	BookingStatusCANCELLED BookingStatus = "CANCELLED"
	BookingStatusREDEEMED  BookingStatus = "REDEEMED"
	BookingStatusPENDING   BookingStatus = "PENDING"
	BookingStatusREJECTED  BookingStatus = "REJECTED"
)

func (e *BookingStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BookingStatus(s)
	case string:
		*e = BookingStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for BookingStatus: %T", src)
	}
	return nil
}

type NullBookingStatus struct {
	BookingStatus BookingStatus `json:"booking_status"`
	Valid         bool          `json:"valid"` // Valid is true if BookingStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBookingStatus) Scan(value interface{}) error {
	if value == nil {
		ns.BookingStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BookingStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBookingStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BookingStatus), nil
}

type ContactField string

const (
	ContactFieldFirstName      ContactField = "firstName"
	ContactFieldLastName       ContactField = "lastName"
	ContactFieldEmailAddress   ContactField = "emailAddress"
	ContactFieldPhoneNumber    ContactField = "phoneNumber"
	ContactFieldCountry        ContactField = "country"
	ContactFieldNotes          ContactField = "notes"
	ContactFieldLocales        ContactField = "locales"
	ContactFieldAllowMarketing ContactField = "allowMarketing"
	ContactFieldPostalCode     ContactField = "postalCode"
)

func (e *ContactField) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ContactField(s)
	case string:
		*e = ContactField(s)
	default:
		return fmt.Errorf("unsupported scan type for ContactField: %T", src)
	}
	return nil
}

type NullContactField struct {
	ContactField ContactField `json:"contact_field"`
	Valid        bool         `json:"valid"` // Valid is true if ContactField is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullContactField) Scan(value interface{}) error {
	if value == nil {
		ns.ContactField, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ContactField.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullContactField) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ContactField), nil
}

type DeliveryFormat string

const (
	DeliveryFormatPDFURL          DeliveryFormat = "PDF_URL"
	DeliveryFormatQRCODE          DeliveryFormat = "QRCODE"
	DeliveryFormatCODE128         DeliveryFormat = "CODE128"
	DeliveryFormatPKPASSURL       DeliveryFormat = "PKPASS_URL"
	DeliveryFormatAZTECCODE       DeliveryFormat = "AZTECCODE"
	DeliveryFormatGOOGLEWALLETURL DeliveryFormat = "GOOGLE_WALLET_URL"
)

func (e *DeliveryFormat) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DeliveryFormat(s)
	case string:
		*e = DeliveryFormat(s)
	default:
		return fmt.Errorf("unsupported scan type for DeliveryFormat: %T", src)
	}
	return nil
}

type NullDeliveryFormat struct {
	DeliveryFormat DeliveryFormat `json:"delivery_format"`
	Valid          bool           `json:"valid"` // Valid is true if DeliveryFormat is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeliveryFormat) Scan(value interface{}) error {
	if value == nil {
		ns.DeliveryFormat, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DeliveryFormat.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDeliveryFormat) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DeliveryFormat), nil
}

type DeliveryMethod string

const (
	DeliveryMethodVOUCHER DeliveryMethod = "VOUCHER"
	DeliveryMethodTICKET  DeliveryMethod = "TICKET"
)

func (e *DeliveryMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DeliveryMethod(s)
	case string:
		*e = DeliveryMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for DeliveryMethod: %T", src)
	}
	return nil
}

type NullDeliveryMethod struct {
	DeliveryMethod DeliveryMethod `json:"delivery_method"`
	Valid          bool           `json:"valid"` // Valid is true if DeliveryMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDeliveryMethod) Scan(value interface{}) error {
	if value == nil {
		ns.DeliveryMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DeliveryMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDeliveryMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DeliveryMethod), nil
}

type DurationUnit string

const (
	DurationUnitHour   DurationUnit = "hour"
	DurationUnitMinute DurationUnit = "minute"
	DurationUnitDay    DurationUnit = "day"
)

func (e *DurationUnit) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DurationUnit(s)
	case string:
		*e = DurationUnit(s)
	default:
		return fmt.Errorf("unsupported scan type for DurationUnit: %T", src)
	}
	return nil
}

type NullDurationUnit struct {
	DurationUnit DurationUnit `json:"duration_unit"`
	Valid        bool         `json:"valid"` // Valid is true if DurationUnit is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDurationUnit) Scan(value interface{}) error {
	if value == nil {
		ns.DurationUnit, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DurationUnit.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDurationUnit) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DurationUnit), nil
}

type InputType string

const (
	InputTypeDate          InputType = "date"
	InputTypeDatetimeLocal InputType = "datetime-local"
	InputTypeEmail         InputType = "email"
	InputTypeFile          InputType = "file"
	InputTypeNumber        InputType = "number"
	InputTypeTel           InputType = "tel"
	InputTypeText          InputType = "text"
	InputTypeTime          InputType = "time"
	InputTypeUrl           InputType = "url"
	InputTypeSelect        InputType = "select"
	InputTypeTextarea      InputType = "textarea"
)

func (e *InputType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InputType(s)
	case string:
		*e = InputType(s)
	default:
		return fmt.Errorf("unsupported scan type for InputType: %T", src)
	}
	return nil
}

type NullInputType struct {
	InputType InputType `json:"input_type"`
	Valid     bool      `json:"valid"` // Valid is true if InputType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInputType) Scan(value interface{}) error {
	if value == nil {
		ns.InputType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InputType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInputType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InputType), nil
}

type NetDiscount string

const (
	NetDiscountNONE     NetDiscount = "NONE"
	NetDiscountFULL     NetDiscount = "FULL"
	NetDiscountSPLIT    NetDiscount = "SPLIT"
	NetDiscountPRORATED NetDiscount = "PRORATED"
)

func (e *NetDiscount) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NetDiscount(s)
	case string:
		*e = NetDiscount(s)
	default:
		return fmt.Errorf("unsupported scan type for NetDiscount: %T", src)
	}
	return nil
}

type NullNetDiscount struct {
	NetDiscount NetDiscount `json:"net_discount"`
	Valid       bool        `json:"valid"` // Valid is true if NetDiscount is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNetDiscount) Scan(value interface{}) error {
	if value == nil {
		ns.NetDiscount, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NetDiscount.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNetDiscount) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NetDiscount), nil
}

type OrderStatus string

const (
	OrderStatusONHOLD    OrderStatus = "ON_HOLD"
	OrderStatusCONFIRMED OrderStatus = "CONFIRMED"
	OrderStatusCANCELLED OrderStatus = "CANCELLED"
	OrderStatusEXPIRED   OrderStatus = "EXPIRED"
	OrderStatusPENDING   OrderStatus = "PENDING"
)

func (e *OrderStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OrderStatus(s)
	case string:
		*e = OrderStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for OrderStatus: %T", src)
	}
	return nil
}

type NullOrderStatus struct {
	OrderStatus OrderStatus `json:"order_status"`
	Valid       bool        `json:"valid"` // Valid is true if OrderStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOrderStatus) Scan(value interface{}) error {
	if value == nil {
		ns.OrderStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OrderStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOrderStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OrderStatus), nil
}

type PricingPer string

const (
	PricingPerUNIT    PricingPer = "UNIT"
	PricingPerBOOKING PricingPer = "BOOKING"
)

func (e *PricingPer) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PricingPer(s)
	case string:
		*e = PricingPer(s)
	default:
		return fmt.Errorf("unsupported scan type for PricingPer: %T", src)
	}
	return nil
}

type NullPricingPer struct {
	PricingPer PricingPer `json:"pricing_per"`
	Valid      bool       `json:"valid"` // Valid is true if PricingPer is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPricingPer) Scan(value interface{}) error {
	if value == nil {
		ns.PricingPer, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PricingPer.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPricingPer) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PricingPer), nil
}

type RedemptionMethod string

const (
	RedemptionMethodDIGITAL  RedemptionMethod = "DIGITAL"
	RedemptionMethodPRINT    RedemptionMethod = "PRINT"
	RedemptionMethodMANIFEST RedemptionMethod = "MANIFEST"
)

func (e *RedemptionMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = RedemptionMethod(s)
	case string:
		*e = RedemptionMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for RedemptionMethod: %T", src)
	}
	return nil
}

type NullRedemptionMethod struct {
	RedemptionMethod RedemptionMethod `json:"redemption_method"`
	Valid            bool             `json:"valid"` // Valid is true if RedemptionMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullRedemptionMethod) Scan(value interface{}) error {
	if value == nil {
		ns.RedemptionMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.RedemptionMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullRedemptionMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.RedemptionMethod), nil
}

type ResellerStatus string

const (
	ResellerStatusACTIVE   ResellerStatus = "ACTIVE"
	ResellerStatusDISABLED ResellerStatus = "DISABLED"
	ResellerStatusDRAFT    ResellerStatus = "DRAFT"
)

func (e *ResellerStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResellerStatus(s)
	case string:
		*e = ResellerStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ResellerStatus: %T", src)
	}
	return nil
}

type NullResellerStatus struct {
	ResellerStatus ResellerStatus `json:"reseller_status"`
	Valid          bool           `json:"valid"` // Valid is true if ResellerStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResellerStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ResellerStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResellerStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResellerStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResellerStatus), nil
}

type UnitType string

const (
	UnitTypeADULT    UnitType = "ADULT"
	UnitTypeYOUTH    UnitType = "YOUTH"
	UnitTypeCHILD    UnitType = "CHILD"
	UnitTypeINFANT   UnitType = "INFANT"
	UnitTypeFAMILY   UnitType = "FAMILY"
	UnitTypeSENIOR   UnitType = "SENIOR"
	UnitTypeSTUDENT  UnitType = "STUDENT"
	UnitTypeMILITARY UnitType = "MILITARY"
	UnitTypeOTHER    UnitType = "OTHER"
)

func (e *UnitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UnitType(s)
	case string:
		*e = UnitType(s)
	default:
		return fmt.Errorf("unsupported scan type for UnitType: %T", src)
	}
	return nil
}

type NullUnitType struct {
	UnitType UnitType `json:"unit_type"`
	Valid    bool     `json:"valid"` // Valid is true if UnitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUnitType) Scan(value interface{}) error {
	if value == nil {
		ns.UnitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UnitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUnitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UnitType), nil
}

type Availability struct {
	ID                   uuid.UUID          `json:"id"`
	OptionID             uuid.UUID          `json:"option_id"`
	LocalDateTimeStart   time.Time          `json:"local_date_time_start"`
	LocalDateTimeEnd     time.Time          `json:"local_date_time_end"`
	AllDay               bool               `json:"all_day"`
	Available            bool               `json:"available"`
	Status               AvailabilityStatus `json:"status"`
	Vacancies            pgtype.Int4        `json:"vacancies"`
	Capacity             pgtype.Int4        `json:"capacity"`
	MaxUnits             pgtype.Int4        `json:"max_units"`
	UtcCutoffAt          time.Time          `json:"utc_cutoff_at"`
	MeetingPointID       pgtype.UUID        `json:"meeting_point_id"`
	MeetingLocalDateTime pgtype.Timestamptz `json:"meeting_local_date_time"`
	TourGroupID          pgtype.UUID        `json:"tour_group_id"`
	PickupAvailable      pgtype.Bool        `json:"pickup_available"`
	PickupRequired       pgtype.Bool        `json:"pickup_required"`
	OfferCode            pgtype.Text        `json:"offer_code"`
	OfferTitle           pgtype.Text        `json:"offer_title"`
	OfferID              pgtype.UUID        `json:"offer_id"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            time.Time          `json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
}

type AvailabilityNotice struct {
	ID             uuid.UUID `json:"id"`
	AvailabilityID uuid.UUID `json:"availability_id"`
	NoticeID       uuid.UUID `json:"notice_id"`
	CreatedAt      time.Time `json:"created_at"`
}

type AvailabilityOffer struct {
	ID             uuid.UUID `json:"id"`
	AvailabilityID uuid.UUID `json:"availability_id"`
	OfferID        uuid.UUID `json:"offer_id"`
	CreatedAt      time.Time `json:"created_at"`
}

type AvailabilityPickupPoint struct {
	ID              uuid.UUID   `json:"id"`
	AvailabilityID  uuid.UUID   `json:"availability_id"`
	PickupPointID   uuid.UUID   `json:"pickup_point_id"`
	LocalDateTime   string      `json:"local_date_time"`
	LocalDateTimeTo pgtype.Text `json:"local_date_time_to"`
	CreatedAt       time.Time   `json:"created_at"`
}

type AvailabilityResource struct {
	ID             uuid.UUID `json:"id"`
	AvailabilityID uuid.UUID `json:"availability_id"`
	ResourceID     uuid.UUID `json:"resource_id"`
	Quantity       int32     `json:"quantity"`
	CreatedAt      time.Time `json:"created_at"`
}

type Booking struct {
	ID                   uuid.UUID          `json:"id"`
	Uuid                 uuid.UUID          `json:"uuid"`
	TestMode             bool               `json:"test_mode"`
	ResellerReference    pgtype.Text        `json:"reseller_reference"`
	SupplierReference    pgtype.Text        `json:"supplier_reference"`
	Status               BookingStatus      `json:"status"`
	UtcCreatedAt         time.Time          `json:"utc_created_at"`
	UtcUpdatedAt         pgtype.Timestamptz `json:"utc_updated_at"`
	UtcExpiresAt         pgtype.Timestamptz `json:"utc_expires_at"`
	UtcRedeemedAt        pgtype.Timestamptz `json:"utc_redeemed_at"`
	UtcConfirmedAt       pgtype.Timestamptz `json:"utc_confirmed_at"`
	ProductID            uuid.UUID          `json:"product_id"`
	OptionID             uuid.UUID          `json:"option_id"`
	Cancellable          bool               `json:"cancellable"`
	Freesale             bool               `json:"freesale"`
	AvailabilityID       pgtype.UUID        `json:"availability_id"`
	ContactID            uuid.UUID          `json:"contact_id"`
	Notes                pgtype.Text        `json:"notes"`
	MeetingPointID       pgtype.UUID        `json:"meeting_point_id"`
	MeetingLocalDateTime pgtype.Timestamptz `json:"meeting_local_date_time"`
	Duration             pgtype.Text        `json:"duration"`
	DurationAmount       pgtype.Text        `json:"duration_amount"`
	DurationUnit         pgtype.Text        `json:"duration_unit"`
	TermsAccepted        pgtype.Bool        `json:"terms_accepted"`
	PickupRequested      pgtype.Bool        `json:"pickup_requested"`
	PickupPointID        pgtype.UUID        `json:"pickup_point_id"`
	PickupHotel          pgtype.Text        `json:"pickup_hotel"`
	PickupHotelRoom      pgtype.Text        `json:"pickup_hotel_room"`
	OrderID              pgtype.Text        `json:"order_id"`
	OrderReference       pgtype.Text        `json:"order_reference"`
	PrimaryBooking       pgtype.Bool        `json:"primary_booking"`
	OfferCode            pgtype.Text        `json:"offer_code"`
	OfferTitle           pgtype.Text        `json:"offer_title"`
	OfferIsCombination   pgtype.Bool        `json:"offer_is_combination"`
	OfferID              pgtype.UUID        `json:"offer_id"`
	CreatedAt            time.Time          `json:"created_at"`
	UpdatedAt            time.Time          `json:"updated_at"`
	DeletedAt            pgtype.Timestamptz `json:"deleted_at"`
}

type BookingContact struct {
	ID        uuid.UUID `json:"id"`
	BookingID uuid.UUID `json:"booking_id"`
	ContactID uuid.UUID `json:"contact_id"`
	CreatedAt time.Time `json:"created_at"`
}

type BookingDeliveryMethod struct {
	ID             uuid.UUID      `json:"id"`
	BookingID      uuid.UUID      `json:"booking_id"`
	DeliveryMethod DeliveryMethod `json:"delivery_method"`
	CreatedAt      time.Time      `json:"created_at"`
}

type BookingNotice struct {
	ID        uuid.UUID `json:"id"`
	BookingID uuid.UUID `json:"booking_id"`
	NoticeID  uuid.UUID `json:"notice_id"`
	CreatedAt time.Time `json:"created_at"`
}

type BookingQuestionAnswer struct {
	ID               uuid.UUID `json:"id"`
	BookingID        uuid.UUID `json:"booking_id"`
	QuestionAnswerID uuid.UUID `json:"question_answer_id"`
	CreatedAt        time.Time `json:"created_at"`
}

type Cancellation struct {
	ID             uuid.UUID   `json:"id"`
	BookingID      uuid.UUID   `json:"booking_id"`
	Refund         string      `json:"refund"`
	Reason         pgtype.Text `json:"reason"`
	UtcCancelledAt time.Time   `json:"utc_cancelled_at"`
	CreatedAt      time.Time   `json:"created_at"`
}

type Contact struct {
	ID             uuid.UUID          `json:"id"`
	FullName       pgtype.Text        `json:"full_name"`
	FirstName      pgtype.Text        `json:"first_name"`
	LastName       pgtype.Text        `json:"last_name"`
	EmailAddress   pgtype.Text        `json:"email_address"`
	PhoneNumber    pgtype.Text        `json:"phone_number"`
	PostalCode     pgtype.Text        `json:"postal_code"`
	Country        pgtype.Text        `json:"country"`
	Notes          pgtype.Text        `json:"notes"`
	AllowMarketing pgtype.Bool        `json:"allow_marketing"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
}

type ContactLocale struct {
	ID        uuid.UUID `json:"id"`
	ContactID uuid.UUID `json:"contact_id"`
	Locale    string    `json:"locale"`
	CreatedAt time.Time `json:"created_at"`
}

type DeliveryOption struct {
	ID             uuid.UUID      `json:"id"`
	TicketID       uuid.UUID      `json:"ticket_id"`
	DeliveryFormat DeliveryFormat `json:"delivery_format"`
	DeliveryValue  string         `json:"delivery_value"`
	CreatedAt      time.Time      `json:"created_at"`
}

type ExtraPricing struct {
	ID        uuid.UUID `json:"id"`
	UnitID    uuid.UUID `json:"unit_id"`
	PricingID uuid.UUID `json:"pricing_id"`
	CreatedAt time.Time `json:"created_at"`
}

type Itinerary struct {
	ID               uuid.UUID `json:"id"`
	OptionContentID  uuid.UUID `json:"option_content_id"`
	Name             string    `json:"name"`
	Type             string    `json:"type"`
	Description      string    `json:"description"`
	Address          string    `json:"address"`
	GooglePlaceID    string    `json:"google_place_id"`
	Latitude         float64   `json:"latitude"`
	Longitude        float64   `json:"longitude"`
	TravelTime       string    `json:"travel_time"`
	TravelTimeAmount int32     `json:"travel_time_amount"`
	TravelTimeUnit   string    `json:"travel_time_unit"`
	Duration         string    `json:"duration"`
	DurationAmount   int32     `json:"duration_amount"`
	DurationUnit     string    `json:"duration_unit"`
	SortOrder        int32     `json:"sort_order"`
	CreatedAt        time.Time `json:"created_at"`
}

type Mapping struct {
	ID                uuid.UUID          `json:"id"`
	ResellerReference string             `json:"reseller_reference"`
	ResellerStatus    ResellerStatus     `json:"reseller_status"`
	Title             string             `json:"title"`
	Url               string             `json:"url"`
	WebhookUrl        pgtype.Text        `json:"webhook_url"`
	OptionRequired    bool               `json:"option_required"`
	UnitRequired      bool               `json:"unit_required"`
	ProductID         pgtype.UUID        `json:"product_id"`
	OptionID          pgtype.UUID        `json:"option_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	Connected         bool               `json:"connected"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}

type MeetingPoint struct {
	ID        uuid.UUID          `json:"id"`
	Name      string             `json:"name"`
	Address   pgtype.Text        `json:"address"`
	Latitude  pgtype.Float8      `json:"latitude"`
	Longitude pgtype.Float8      `json:"longitude"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type Notice struct {
	ID               uuid.UUID          `json:"id"`
	Title            pgtype.Text        `json:"title"`
	ShortDescription string             `json:"short_description"`
	CoverImageUrl    pgtype.Text        `json:"cover_image_url"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type Offer struct {
	ID          uuid.UUID          `json:"id"`
	ProductID   uuid.UUID          `json:"product_id"`
	OptionID    pgtype.UUID        `json:"option_id"`
	Title       string             `json:"title"`
	Code        string             `json:"code"`
	Description pgtype.Text        `json:"description"`
	NetDiscount NullNetDiscount    `json:"net_discount"`
	Usable      bool               `json:"usable"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
}

type OfferCombination struct {
	ID               uuid.UUID          `json:"id"`
	ProductID        uuid.UUID          `json:"product_id"`
	OptionID         uuid.UUID          `json:"option_id"`
	OfferCode        string             `json:"offer_code"`
	OfferTitle       string             `json:"offer_title"`
	ShortDescription pgtype.Text        `json:"short_description"`
	PricingID        uuid.UUID          `json:"pricing_id"`
	BookingID        pgtype.UUID        `json:"booking_id"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type OfferCombinationUnit struct {
	ID                 uuid.UUID `json:"id"`
	OfferCombinationID uuid.UUID `json:"offer_combination_id"`
	UnitID             uuid.UUID `json:"unit_id"`
	Quantity           int32     `json:"quantity"`
	CreatedAt          time.Time `json:"created_at"`
}

type OfferDiscount struct {
	ID        uuid.UUID          `json:"id"`
	OfferID   uuid.UUID          `json:"offer_id"`
	Net       pgtype.Int4        `json:"net"`
	Retail    int32              `json:"retail"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type OfferDiscountTax struct {
	ID              uuid.UUID `json:"id"`
	OfferDiscountID uuid.UUID `json:"offer_discount_id"`
	TaxID           uuid.UUID `json:"tax_id"`
	CreatedAt       time.Time `json:"created_at"`
}

type OfferRestriction struct {
	ID        uuid.UUID          `json:"id"`
	OfferID   uuid.UUID          `json:"offer_id"`
	MinUnits  pgtype.Int4        `json:"min_units"`
	MaxUnits  pgtype.Int4        `json:"max_units"`
	MinTotal  pgtype.Int4        `json:"min_total"`
	MaxTotal  pgtype.Int4        `json:"max_total"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type OfferRestrictionsUnit struct {
	ID                  uuid.UUID `json:"id"`
	OfferRestrictionsID uuid.UUID `json:"offer_restrictions_id"`
	UnitID              uuid.UUID `json:"unit_id"`
	CreatedAt           time.Time `json:"created_at"`
}

type OpeningHour struct {
	ID              uuid.UUID   `json:"id"`
	AvailabilityID  uuid.UUID   `json:"availability_id"`
	FromTime        string      `json:"from_time"`
	ToTime          string      `json:"to_time"`
	Frequency       pgtype.Text `json:"frequency"`
	FrequencyAmount pgtype.Int4 `json:"frequency_amount"`
	FrequencyUnit   pgtype.Text `json:"frequency_unit"`
	CreatedAt       time.Time   `json:"created_at"`
}

type Option struct {
	ID                       uuid.UUID          `json:"id"`
	ProductID                uuid.UUID          `json:"product_id"`
	IsDefault                bool               `json:"is_default"`
	InternalName             string             `json:"internal_name"`
	Reference                pgtype.Text        `json:"reference"`
	CancellationCutoff       string             `json:"cancellation_cutoff"`
	CancellationCutoffAmount int32              `json:"cancellation_cutoff_amount"`
	CancellationCutoffUnit   string             `json:"cancellation_cutoff_unit"`
	AvailabilityCutoff       string             `json:"availability_cutoff"`
	AvailabilityCutoffAmount int32              `json:"availability_cutoff_amount"`
	AvailabilityCutoffUnit   string             `json:"availability_cutoff_unit"`
	MinUnits                 int32              `json:"min_units"`
	MaxUnits                 int32              `json:"max_units"`
	MinPaxCount              int32              `json:"min_pax_count"`
	MaxPaxCount              int32              `json:"max_pax_count"`
	OptionContentID          uuid.UUID          `json:"option_content_id"`
	OptionPickupsID          pgtype.UUID        `json:"option_pickups_id"`
	CreatedAt                time.Time          `json:"created_at"`
	UpdatedAt                time.Time          `json:"updated_at"`
	DeletedAt                pgtype.Timestamptz `json:"deleted_at"`
}

type OptionAvailabilityTime struct {
	ID        uuid.UUID `json:"id"`
	OptionID  uuid.UUID `json:"option_id"`
	LocalTime string    `json:"local_time"`
	CreatedAt time.Time `json:"created_at"`
}

type OptionContactField struct {
	ID         uuid.UUID    `json:"id"`
	OptionID   uuid.UUID    `json:"option_id"`
	Field      ContactField `json:"field"`
	IsRequired bool         `json:"is_required"`
	IsVisible  bool         `json:"is_visible"`
	CreatedAt  time.Time    `json:"created_at"`
}

type OptionContent struct {
	ID               uuid.UUID          `json:"id"`
	Title            pgtype.Text        `json:"title"`
	Subtitle         pgtype.Text        `json:"subtitle"`
	Language         pgtype.Text        `json:"language"`
	ShortDescription pgtype.Text        `json:"short_description"`
	Duration         pgtype.Text        `json:"duration"`
	DurationAmount   pgtype.Text        `json:"duration_amount"`
	DurationUnit     NullDurationUnit   `json:"duration_unit"`
	CoverImageUrl    pgtype.Text        `json:"cover_image_url"`
	FromPointID      pgtype.UUID        `json:"from_point_id"`
	ToPointID        pgtype.UUID        `json:"to_point_id"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type OptionPickup struct {
	ID              uuid.UUID          `json:"id"`
	PickupRequired  pgtype.Bool        `json:"pickup_required"`
	PickupAvailable pgtype.Bool        `json:"pickup_available"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type OptionPickupPoint struct {
	ID              uuid.UUID `json:"id"`
	OptionPickupsID uuid.UUID `json:"option_pickups_id"`
	PickupPointID   uuid.UUID `json:"pickup_point_id"`
	CreatedAt       time.Time `json:"created_at"`
}

type Order struct {
	ID                uuid.UUID          `json:"id"`
	TestMode          bool               `json:"test_mode"`
	SupplierReference string             `json:"supplier_reference"`
	SettlementMethod  string             `json:"settlement_method"`
	Status            OrderStatus        `json:"status"`
	UtcExpiresAt      pgtype.Timestamptz `json:"utc_expires_at"`
	UtcConfirmedAt    pgtype.Timestamptz `json:"utc_confirmed_at"`
	Cancellable       bool               `json:"cancellable"`
	ContactID         uuid.UUID          `json:"contact_id"`
	TermsAccepted     pgtype.Bool        `json:"terms_accepted"`
	ReturnUrl         pgtype.Text        `json:"return_url"`
	Confirmable       pgtype.Bool        `json:"confirmable"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}

type OrderBooking struct {
	ID        uuid.UUID `json:"id"`
	OrderID   uuid.UUID `json:"order_id"`
	BookingID uuid.UUID `json:"booking_id"`
	CreatedAt time.Time `json:"created_at"`
}

type PickupPoint struct {
	ID              uuid.UUID          `json:"id"`
	Name            string             `json:"name"`
	Directions      pgtype.Text        `json:"directions"`
	Address         string             `json:"address"`
	Latitude        pgtype.Float8      `json:"latitude"`
	Longitude       pgtype.Float8      `json:"longitude"`
	GooglePlaceID   pgtype.Text        `json:"google_place_id"`
	Street          pgtype.Text        `json:"street"`
	PostalCode      pgtype.Text        `json:"postal_code"`
	Locality        pgtype.Text        `json:"locality"`
	Region          pgtype.Text        `json:"region"`
	State           pgtype.Text        `json:"state"`
	Country         pgtype.Text        `json:"country"`
	LocalDateTime   string             `json:"local_date_time"`
	LocalDateTimeTo pgtype.Text        `json:"local_date_time_to"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type Point struct {
	ID               uuid.UUID          `json:"id"`
	InternalName     string             `json:"internal_name"`
	ShortDescription string             `json:"short_description"`
	Title            string             `json:"title"`
	PointGroupID     pgtype.UUID        `json:"point_group_id"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type PointGroup struct {
	ID               uuid.UUID          `json:"id"`
	Title            string             `json:"title"`
	ShortDescription string             `json:"short_description"`
	InternalName     string             `json:"internal_name"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type Pricing struct {
	ID                uuid.UUID          `json:"id"`
	OptionID          pgtype.UUID        `json:"option_id"`
	UnitID            pgtype.UUID        `json:"unit_id"`
	AvailabilityID    pgtype.UUID        `json:"availability_id"`
	BookingID         pgtype.UUID        `json:"booking_id"`
	UnitItemID        pgtype.UUID        `json:"unit_item_id"`
	OrderID           pgtype.UUID        `json:"order_id"`
	PricingType       string             `json:"pricing_type"`
	UnitType          NullUnitType       `json:"unit_type"`
	Original          int32              `json:"original"`
	Retail            int32              `json:"retail"`
	Net               pgtype.Int4        `json:"net"`
	Currency          string             `json:"currency"`
	CurrencyPrecision int32              `json:"currency_precision"`
	OfferDiscountID   pgtype.UUID        `json:"offer_discount_id"`
	ExtraID           pgtype.UUID        `json:"extra_id"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}

type PricingTax struct {
	ID        uuid.UUID `json:"id"`
	PricingID uuid.UUID `json:"pricing_id"`
	TaxID     uuid.UUID `json:"tax_id"`
	CreatedAt time.Time `json:"created_at"`
}

type Product struct {
	ID                     uuid.UUID          `json:"id"`
	InternalName           string             `json:"internal_name"`
	Reference              pgtype.Text        `json:"reference"`
	Locale                 string             `json:"locale"`
	TimeZone               string             `json:"time_zone"`
	AllowFreesale          bool               `json:"allow_freesale"`
	InstantConfirmation    bool               `json:"instant_confirmation"`
	InstantDelivery        bool               `json:"instant_delivery"`
	AvailabilityRequired   bool               `json:"availability_required"`
	AvailabilityType       AvailabilityType   `json:"availability_type"`
	RedemptionMethod       RedemptionMethod   `json:"redemption_method"`
	FreesaleDurationAmount int32              `json:"freesale_duration_amount"`
	FreesaleDurationUnit   string             `json:"freesale_duration_unit"`
	ProductContentID       uuid.UUID          `json:"product_content_id"`
	ProductPricingID       uuid.UUID          `json:"product_pricing_id"`
	ProductPackageID       uuid.UUID          `json:"product_package_id"`
	ProductQuestionsID     pgtype.UUID        `json:"product_questions_id"`
	CreatedAt              time.Time          `json:"created_at"`
	UpdatedAt              time.Time          `json:"updated_at"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
}

type ProductContent struct {
	ID                     uuid.UUID          `json:"id"`
	Title                  pgtype.Text        `json:"title"`
	Country                pgtype.Text        `json:"country"`
	Location               pgtype.Text        `json:"location"`
	Subtitle               pgtype.Text        `json:"subtitle"`
	ShortDescription       pgtype.Text        `json:"short_description"`
	Description            pgtype.Text        `json:"description"`
	Highlights             pgtype.Text        `json:"highlights"`
	Inclusions             pgtype.Text        `json:"inclusions"`
	Exclusions             pgtype.Text        `json:"exclusions"`
	BookingTerms           pgtype.Text        `json:"booking_terms"`
	RedemptionInstructions pgtype.Text        `json:"redemption_instructions"`
	CancellationPolicy     pgtype.Text        `json:"cancellation_policy"`
	Destination            pgtype.Text        `json:"destination"`
	Categories             pgtype.Text        `json:"categories"`
	Faqs                   pgtype.Text        `json:"faqs"`
	CoverImageUrl          pgtype.Text        `json:"cover_image_url"`
	BannerImageUrl         pgtype.Text        `json:"banner_image_url"`
	VideoUrl               pgtype.Text        `json:"video_url"`
	GalleryImages          pgtype.Text        `json:"gallery_images"`
	BannerImages           pgtype.Text        `json:"banner_images"`
	PointToPoint           pgtype.Bool        `json:"point_to_point"`
	PrivacyTerms           pgtype.Text        `json:"privacy_terms"`
	Alert                  pgtype.Text        `json:"alert"`
	CreatedAt              time.Time          `json:"created_at"`
	UpdatedAt              time.Time          `json:"updated_at"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
}

type ProductDeliveryFormat struct {
	ID             uuid.UUID      `json:"id"`
	ProductID      uuid.UUID      `json:"product_id"`
	DeliveryFormat DeliveryFormat `json:"delivery_format"`
	CreatedAt      time.Time      `json:"created_at"`
}

type ProductDeliveryMethod struct {
	ID             uuid.UUID      `json:"id"`
	ProductID      uuid.UUID      `json:"product_id"`
	DeliveryMethod DeliveryMethod `json:"delivery_method"`
	CreatedAt      time.Time      `json:"created_at"`
}

type ProductPackage struct {
	ID        uuid.UUID          `json:"id"`
	IsPackage bool               `json:"is_package"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type ProductPricing struct {
	ID              uuid.UUID          `json:"id"`
	DefaultCurrency pgtype.Text        `json:"default_currency"`
	PricingPer      NullPricingPer     `json:"pricing_per"`
	IncludeTax      pgtype.Bool        `json:"include_tax"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type ProductPricingCurrency struct {
	ID               uuid.UUID `json:"id"`
	ProductPricingID uuid.UUID `json:"product_pricing_id"`
	Currency         string    `json:"currency"`
	CreatedAt        time.Time `json:"created_at"`
}

type ProductQuestion struct {
	ID        uuid.UUID          `json:"id"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type Question struct {
	ID                 uuid.UUID          `json:"id"`
	ProductQuestionsID uuid.UUID          `json:"product_questions_id"`
	Title              string             `json:"title"`
	ShortDescription   string             `json:"short_description"`
	Required           bool               `json:"required"`
	InputType          InputType          `json:"input_type"`
	CoverImageUrl      string             `json:"cover_image_url"`
	CreatedAt          time.Time          `json:"created_at"`
	UpdatedAt          time.Time          `json:"updated_at"`
	DeletedAt          pgtype.Timestamptz `json:"deleted_at"`
}

type QuestionAnswer struct {
	ID         uuid.UUID `json:"id"`
	QuestionID uuid.UUID `json:"question_id"`
	BookingID  uuid.UUID `json:"booking_id"`
	Value      string    `json:"value"`
	CreatedAt  time.Time `json:"created_at"`
}

type QuestionSelectOption struct {
	ID         uuid.UUID `json:"id"`
	QuestionID uuid.UUID `json:"question_id"`
	Label      string    `json:"label"`
	Value      string    `json:"value"`
	SortOrder  int32     `json:"sort_order"`
	CreatedAt  time.Time `json:"created_at"`
}

type Resource struct {
	ID              uuid.UUID          `json:"id"`
	ResourceGroupID uuid.UUID          `json:"resource_group_id"`
	Title           string             `json:"title"`
	Seating         bool               `json:"seating"`
	CreatedAt       time.Time          `json:"created_at"`
	UpdatedAt       time.Time          `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
}

type ResourceAllocation struct {
	ID              uuid.UUID `json:"id"`
	BookingID       uuid.UUID `json:"booking_id"`
	ResourceGroupID uuid.UUID `json:"resource_group_id"`
	ResourceID      uuid.UUID `json:"resource_id"`
	PaxCount        int32     `json:"pax_count"`
	CreatedAt       time.Time `json:"created_at"`
}

type ResourceAllocationSeat struct {
	ID                   uuid.UUID `json:"id"`
	ResourceAllocationID uuid.UUID `json:"resource_allocation_id"`
	SeatID               uuid.UUID `json:"seat_id"`
	CreatedAt            time.Time `json:"created_at"`
}

type ResourceGroup struct {
	ID        uuid.UUID          `json:"id"`
	Title     string             `json:"title"`
	Split     bool               `json:"split"`
	CreatedAt time.Time          `json:"created_at"`
	UpdatedAt time.Time          `json:"updated_at"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

type Seat struct {
	ID         uuid.UUID          `json:"id"`
	ResourceID uuid.UUID          `json:"resource_id"`
	Title      string             `json:"title"`
	ColumnNum  int32              `json:"column_num"`
	RowNum     int32              `json:"row_num"`
	CreatedAt  time.Time          `json:"created_at"`
	UpdatedAt  time.Time          `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
}

type Tax struct {
	ID          uuid.UUID          `json:"id"`
	Type        string             `json:"type"`
	Description string             `json:"description"`
	Amount      int32              `json:"amount"`
	Percentage  pgtype.Float8      `json:"percentage"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
}

type Ticket struct {
	ID               uuid.UUID          `json:"id"`
	BookingID        uuid.UUID          `json:"booking_id"`
	RedemptionMethod RedemptionMethod   `json:"redemption_method"`
	UtcRedeemedAt    pgtype.Timestamptz `json:"utc_redeemed_at"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        time.Time          `json:"updated_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

type TourGroup struct {
	ID           uuid.UUID          `json:"id"`
	InternalName string             `json:"internal_name"`
	Title        string             `json:"title"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
}

type Unit struct {
	ID            uuid.UUID          `json:"id"`
	OptionID      uuid.UUID          `json:"option_id"`
	InternalName  string             `json:"internal_name"`
	Reference     string             `json:"reference"`
	Type          UnitType           `json:"type"`
	MinAge        int32              `json:"min_age"`
	MaxAge        int32              `json:"max_age"`
	IDRequired    bool               `json:"id_required"`
	MinQuantity   pgtype.Int4        `json:"min_quantity"`
	MaxQuantity   pgtype.Int4        `json:"max_quantity"`
	PaxCount      int32              `json:"pax_count"`
	UnitContentID pgtype.UUID        `json:"unit_content_id"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	DeletedAt     pgtype.Timestamptz `json:"deleted_at"`
}

type UnitAccompaniedBy struct {
	ID                    uuid.UUID `json:"id"`
	UnitID                uuid.UUID `json:"unit_id"`
	AccompaniedByUnitType UnitType  `json:"accompanied_by_unit_type"`
	CreatedAt             time.Time `json:"created_at"`
}

type UnitContactField struct {
	ID         uuid.UUID    `json:"id"`
	UnitID     uuid.UUID    `json:"unit_id"`
	Field      ContactField `json:"field"`
	IsRequired bool         `json:"is_required"`
	IsVisible  bool         `json:"is_visible"`
	CreatedAt  time.Time    `json:"created_at"`
}

type UnitContent struct {
	ID          uuid.UUID          `json:"id"`
	Title       pgtype.Text        `json:"title"`
	TitlePlural pgtype.Text        `json:"title_plural"`
	Subtitle    pgtype.Text        `json:"subtitle"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
	DeletedAt   pgtype.Timestamptz `json:"deleted_at"`
}

type UnitItem struct {
	ID                uuid.UUID          `json:"id"`
	Uuid              uuid.UUID          `json:"uuid"`
	BookingID         uuid.UUID          `json:"booking_id"`
	UnitID            uuid.UUID          `json:"unit_id"`
	ResellerReference pgtype.Text        `json:"reseller_reference"`
	SupplierReference pgtype.Text        `json:"supplier_reference"`
	Status            BookingStatus      `json:"status"`
	UtcRedeemedAt     pgtype.Timestamptz `json:"utc_redeemed_at"`
	ContactID         pgtype.UUID        `json:"contact_id"`
	TicketID          pgtype.UUID        `json:"ticket_id"`
	PricingID         pgtype.UUID        `json:"pricing_id"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	DeletedAt         pgtype.Timestamptz `json:"deleted_at"`
}
